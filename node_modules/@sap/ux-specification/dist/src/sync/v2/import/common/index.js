"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const page_1 = require("../../../../specification/common/page");
const table_1 = require("../controls/table");
const common_1 = require("../../../common");
const Manifest_1 = require("../../../../specification/common/webapp/manifest/Manifest");
const decorators_1 = require("../../../common/decoration/decorators");
const manifest_1 = require("../../export/manifest");
const v2_1 = require("../../../../specification/v2");
const extensionLogger_1 = require("../../../../extensionLogger");
const i18next_1 = __importDefault(require("i18next"));
function convertSelector(selectorId) {
    return selectorId
        .replace(/:2f/g, '/')
        .replace(/:23/g, '#')
        .replace(/:40/g, '@');
}
exports.convertSelector = convertSelector;
/**
 * Adds flex changes to Smart Filter Bar in config file
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {string} changePropertyKey - property key of current change
 * @param {ChangeDefinition} change - change definition
 * @param {object} jsonSchema - application specific schema
 */
function addSmartFilterBarFlex(config, changePropertyKey, change, jsonSchema) {
    var _a, _b, _c, _d;
    const schemaProperty = ((_b = (_a = jsonSchema['definitions']) === null || _a === void 0 ? void 0 : _a['ListReportFilterBar']) === null || _b === void 0 ? void 0 : _b.properties[changePropertyKey]) || ((_d = (_c = jsonSchema['definitions']) === null || _c === void 0 ? void 0 : _c['AnalyticalListPageFilterBar']) === null || _d === void 0 ? void 0 : _d.properties[changePropertyKey]);
    if (schemaProperty) {
        config.filterBar[changePropertyKey] = change.content.newBinding
            ? change.content.newBinding
            : change.content.newValue;
    }
}
/**
 * Adds flex changes to ToolBar Actions in config file
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {string} changePropertyKey - property key of current change
 * @param {ChangeDefinition} change - change definition
 * @param {object} jsonSchema - application specific schema
 */
function addToolBarActionFlex(config, changePropertyKey, change, jsonSchema) {
    var _a, _b;
    const actionId = change.controlId.split('--action::')[1];
    const schemaProperty = (_b = (_a = jsonSchema['definitions']) === null || _a === void 0 ? void 0 : _a[`ToolBarAction<${actionId}>`]) === null || _b === void 0 ? void 0 : _b.properties[changePropertyKey];
    const configPart = config.table.toolBar.actions[actionId];
    if (schemaProperty && configPart) {
        configPart[changePropertyKey] = change.content.newBinding ? change.content.newBinding : change.content.newValue;
    }
}
/**
 * Adds flex changes to Smart Chart in config file
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {string} changePropertyKey - property key of current change
 * @param {ChangeDefinition} change - change definition
 * @param {object} jsonSchema - application specific schema
 */
function addSmartChartFlex(config, changePropertyKey, change, jsonSchema) {
    var _a;
    const schemaProperty = jsonSchema['definitions']['ChartSettings'].properties[changePropertyKey];
    if (schemaProperty) {
        const syncRule = decorators_1.getReflectMetadata(config['chart'], changePropertyKey);
        if ((_a = syncRule === null || syncRule === void 0 ? void 0 : syncRule.flex) === null || _a === void 0 ? void 0 : _a.importFlexValue) {
            syncRule.flex.importFlexValue(change, config['chart'], changePropertyKey);
        }
        else {
            config['chart'][changePropertyKey] = change.content.newBinding
                ? change.content.newBinding
                : change.content.newValue;
        }
    }
}
/**
 * Checks and adds further flex changes to in config file
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {ChangeDefinition} change - change definition
 * @param {object} jsonSchema - application specific schema
 */
function addAdditionalFlexChanges(config, change, jsonSchema) {
    const flexForTransfer = {
        controlId: change.controlId,
        propertyId: change.content.property,
        newValue: change.content.newBinding ? change.content.newBinding : change.content.newValue,
        controlType: change.controlType
    };
    let constructorName;
    if ((!config.table.type || config.table.type === v2_1.TableTypeV2.ResponsiveTable) &&
        !flexForTransfer.controlId.includes(page_1.PAGETYPE_VIEW_EXTENSION_TEMPLATE_MAP.get(page_1.PageType.AnalyticalListPage))) {
        constructorName = 'ResponsiveTableWithMultiSelect';
    }
    else {
        constructorName = config.table.constructor.name;
    }
    const schemaProperty = jsonSchema['definitions'][`${constructorName}<LineItems>`].properties[flexForTransfer.propertyId];
    if (schemaProperty || flexForTransfer.controlType === common_1.ControlType.TableColumn) {
        table_1.addFlexForTable(config.table, flexForTransfer, jsonSchema);
    }
}
/**
 * Adds flex changes to config file
 * @param {ListReportConfig | AnalyticalListPageConfig} config - the configuration to be filled
 * @param {string} changeString - change file as string
 * @param {object} jsonSchema - application specific schema
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function addFlex(config, changeString, jsonSchema, logger) {
    var _a, _b;
    try {
        const change = common_1.parseChangeString(changeString);
        const changePropertyKey = change.content.property;
        if (((_a = change.controlId) === null || _a === void 0 ? void 0 : _a.includes(page_1.PageType.ListReport)) || ((_b = change.controlId) === null || _b === void 0 ? void 0 : _b.includes(page_1.PageType.AnalyticalListPage))) {
            change.controlId = convertSelector(change.controlId);
            switch (change.controlType) {
                case common_1.ControlType.SmartFilterBar: {
                    addSmartFilterBarFlex(config, changePropertyKey, change, jsonSchema);
                    break;
                }
                case common_1.ControlType.DynamicPage: {
                    const schemaProperty = jsonSchema['properties'][changePropertyKey];
                    if (schemaProperty) {
                        config[change.content.property] = change.content.newValue;
                    }
                    break;
                }
                case common_1.ControlType.Button: {
                    addToolBarActionFlex(config, changePropertyKey, change, jsonSchema);
                    break;
                }
                case common_1.ControlType.SmartChart: {
                    addSmartChartFlex(config, changePropertyKey, change, jsonSchema);
                    break;
                }
                default: {
                    addAdditionalFlexChanges(config, change, jsonSchema);
                    break;
                }
            }
        }
    }
    catch (error) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('FLEXERROR')
        }, ...error);
    }
}
exports.addFlex = addFlex;
/**
 * Transfers settings from manifest to object page config
 * @param configPart - part of the configuration to be filled
 * @param manifest - manifest.json of the app
 * @param appSchema - app specific schema
 * @param pageID - ID of the given object page
 * @param sectionId (optional) - ID of the given section (optional)
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function transferSettingsOfObject(configPart, manifest, appSchema, pageKey, logger, kpiKey) {
    if (!appSchema) {
        return;
    }
    let manifestSection = {};
    const deprecatedProperties = configPart.getDeprecated ? configPart.getDeprecated() : [];
    if (appSchema['properties']) {
        for (const propertyKey in appSchema['properties']) {
            const syncRule = decorators_1.getReflectMetadata(configPart, propertyKey);
            if (syncRule === null || syncRule === void 0 ? void 0 : syncRule.manifest) {
                const path = syncRule.manifest.path([pageKey], undefined, kpiKey);
                manifestSection = manifest_1.getManifestSectionByPathV2(manifest, path);
                common_1.importProperty(syncRule, manifestSection, propertyKey, configPart);
                common_1.checkDeprecatedProperties(deprecatedProperties, manifestSection, path, logger);
            }
            // Adjustment of 'quickVariantSelectionX' - tableSettings
            if (propertyKey === 'quickVariantSelectionX' && configPart[propertyKey]) {
                for (const variant in configPart[propertyKey]['variants']) {
                    const currentQuickVariantX = configPart[propertyKey]['variants'][variant];
                    if (currentQuickVariantX['tableSettings']) {
                        for (const key in currentQuickVariantX['tableSettings']) {
                            currentQuickVariantX[key] = currentQuickVariantX['tableSettings'][key];
                        }
                        delete currentQuickVariantX['tableSettings'];
                    }
                }
            }
        }
    }
}
exports.transferSettingsOfObject = transferSettingsOfObject;
/**
 * Determines the table type for a given LR or ALP table, based on the component name and its table settings
 * This does not exactly reflect the run time behavior of Fiori elements but a best guess and expectation.
 * @param manifest - manifest.json file content of the app
 * @param pageKey - key of the page in the manifest
 */
function determineTableType(manifest, pageKey) {
    var _a, _b;
    const page = manifest[Manifest_1.ManifestSection.generic].pages[pageKey];
    let tableType = v2_1.TableTypeV2.ResponsiveTable;
    if (manifest[Manifest_1.ManifestSection.generic].pages[pageKey].component.settings &&
        ((manifest[Manifest_1.ManifestSection.generic].pages[pageKey].component.settings.tableSettings &&
            manifest[Manifest_1.ManifestSection.generic].pages[pageKey].component.settings.tableSettings['type']) ||
            manifest[Manifest_1.ManifestSection.generic].pages[pageKey].component.settings['tableType'])) {
        tableType = ((_b = (_a = page.component.settings) === null || _a === void 0 ? void 0 : _a.tableSettings) === null || _b === void 0 ? void 0 : _b['type']) || page.component.settings['tableType'];
    }
    else if (page.component.name === 'sap.suite.ui.generic.template.AnalyticalListPage') {
        tableType = v2_1.TableTypeV2.AnalyticalTable;
    }
    return tableType;
}
exports.determineTableType = determineTableType;
//# sourceMappingURL=index.js.map